  {{#debugging?}}
    PROCEDURE fc_print_long_clob(
        wp_clob CLOB
    )
    AS
        wl_buffer VARCHAR2(4000);
        wl_offset INT := 1;
        wl_total INT;
    BEGIN

        dbms_output.enable(buffer_size => NULL);

        wl_total := length(wp_clob);

        WHILE wl_offset < wl_total LOOP

            wl_buffer := dbms_lob.substr(wp_clob, 4000, wl_offset);
            dbms_output.put_line(wl_buffer);
            wl_offset := wl_offset + length(wl_buffer);

        END LOOP;

        dbms_output.put_line('');

    END fc_print_long_clob;
  {{/debugging?}}

    FUNCTION fc_post
    (
        wp_url IN VARCHAR2,
        wp_data IN CLOB,
        wp_soap_action VARCHAR2 DEFAULT NULL
    )
        RETURN CLOB
    IS
        --
        wl_request  utl_http.req;
        wl_response utl_http.resp;
        wl_buffer   CLOB;
        wl_chunk    VARCHAR2(4000);
        wl_length   NUMBER;
        wl_index    NUMBER;
        wl_dbms_max NUMBER := 10000;
    BEGIN

        wl_index := 1;
        wl_length := NVL(length(wp_data), 0);
      {{#debugging?}}
        dbms_output.enable(1000000);

        dbms_output.put_line('CONNECTING TO: ' || wp_url);
        IF LENGTH(wp_data) < wl_dbms_max THEN
            dbms_output.put_line('REQUEST: ' || wp_data);
        ELSE
            dbms_output.put_line('REQUEST: ');
            fc_print_long_clob(wp_data);
        END IF;
      {{/debugging?}}

        -- configure HTTP
        utl_http.set_response_error_check(enable => FALSE);
        utl_http.set_detailed_excp_support(enable => FALSE);

        -- send request
        wl_request := utl_http.begin_request(wp_url, 'POST','HTTP/1.1');
        utl_http.set_header(wl_request, 'Content-Type', 'text/xml');
        utl_http.set_header(wl_request, 'Content-Length', wl_length);

        IF wp_soap_action IS NOT NULL THEN
          utl_http.set_header(wl_request, 'soapAction', wp_soap_action);
        END IF;

        WHILE wl_index <= wl_length LOOP
            utl_http.write_text(wl_request, substr(wp_data, wl_index, 4000));
            wl_index := wl_index + 4000;
        END LOOP;

        -- get response
        wl_response := utl_http.get_response(wl_request);
        dbms_lob.createtemporary(wl_buffer, FALSE);
        BEGIN
            LOOP
                utl_http.read_text(wl_response, wl_chunk, 4000);
                dbms_lob.writeappend(wl_buffer, length(wl_chunk), wl_chunk);
            END LOOP;
        EXCEPTION
            WHEN utl_http.end_of_body THEN NULL;
        END;
        utl_http.end_response(wl_response);

      {{#debugging?}}
        IF LENGTH(wl_buffer) < wl_dbms_max THEN
            dbms_output.put_line('RESPONSE: ' || wl_buffer);
        ELSE
            dbms_output.put_line('RESPONSE: ');
            fc_print_long_clob(wl_buffer);
        END IF;
      {{/debugging?}}

        RETURN wl_buffer;

    END fc_post;

    FUNCTION fc_to_date(
        wp_string varchar2
    )
    RETURN TIMESTAMP WITH TIME ZONE
    AS
        wl_result TIMESTAMP WITH TIME ZONE;
        wl_oracle_format VARCHAR2(100);
    BEGIN

        IF (regexp_instr(wp_string, '\d{4}-\d{2}-\d{2}(([+-]\d{2}:\d{2})Z])?') > 0) THEN
            wl_oracle_format := 'YYYY-MM-DDTZH:TZM';
        ELSIF (regexp_instr(wp_string, '\d{4}-\d{2}(([+-]\d{2}:\d{2})Z])?') > 0) THEN
            wl_oracle_format := 'YYYY-MMTZH:TZM';
        ELSIF (regexp_instr(wp_string, '\d{4}(([+-]\d{2}:\d{2})Z])?') > 0) THEN
            wl_oracle_format := 'YYYYTZH:TZM';
        END IF;

        RETURN to_timestamp_tz(wp_string, wl_oracle_format);

    END fc_to_date;

    FUNCTION fc_to_time(
        wp_string varchar2
    )
    RETURN TIMESTAMP WITH TIME ZONE
    AS
        wl_result TIMESTAMP WITH TIME ZONE;
        wl_oracle_format VARCHAR2(100);
    BEGIN

        IF (regexp_instr(wp_string, '\d{2}:\d{2}(:\d{2})?(.\d{0,6})?([+-]\d{2}:\d{2})?') > 0) THEN
            wl_oracle_format := 'HH24:MI:SS.FF9TZH:TZM';
        END IF;

        RETURN to_timestamp_tz(wp_string, wl_oracle_format);

    END fc_to_time;

    FUNCTION fc_to_datetime(
        wp_string varchar2
    )
    RETURN TIMESTAMP WITH TIME ZONE
    AS
        wl_result TIMESTAMP WITH TIME ZONE;
        wl_oracle_format VARCHAR2(100);
    BEGIN

        IF (regexp_instr(wp_string, '\d{4}-\d{2}-\d{2}(T\d{2}:\d{2})?(:\d{2})?(.\d{0,6})?([+-]\d{2}:\d{2})?') > 0) THEN
            wl_oracle_format := 'YYYY-MM-DD"T"HH24:MI:SS.FF9TZH:TZM'; --show errors
        END IF;

        RETURN to_timestamp_tz(wp_string, wl_oracle_format);

    END fc_to_datetime;

    FUNCTION decode_base64(p_clob_in in clob) RETURN blob is
        v_blob blob;
        v_result blob;
        v_offset integer;
        v_buffer_size binary_integer := 48;
        v_buffer_varchar varchar2(48);
        v_buffer_raw raw(48);
      begin
        IF p_clob_in is null then
          RETURN null;
        END IF;
        dbms_lob.createtemporary(v_blob, true);
        v_offset := 1;
        FOR i in 1 .. ceil(dbms_lob.getlength(p_clob_in) / v_buffer_size) LOOP
          dbms_lob.read(p_clob_in, v_buffer_size, v_offset, v_buffer_varchar);
          v_buffer_raw := utl_raw.cast_to_raw(v_buffer_varchar);
          v_buffer_raw := utl_encode.base64_decode(v_buffer_raw);
          dbms_lob.writeappend(v_blob, utl_raw.length(v_buffer_raw), v_buffer_raw);
          v_offset := v_offset + v_buffer_size;
        END LOOP;
        v_result := v_blob;
        dbms_lob.freetemporary(v_blob);
        RETURN v_result;
      END decode_base64;

      FUNCTION encode_base64(p_blob_in in blob) RETURN clob is
        v_clob clob;
        v_result clob;
        v_offset integer;
        v_chunk_size binary_integer := (48 / 4) * 3;
        v_buffer_varchar varchar2(48);
        v_buffer_raw raw(48);
      begin
        IF p_blob_in is null then
          RETURN null;
        END IF;
        dbms_lob.createtemporary(v_clob, true);
        v_offset := 1;
        FOR i in 1 .. ceil(dbms_lob.getlength(p_blob_in) / v_chunk_size) LOOP
          dbms_lob.read(p_blob_in, v_chunk_size, v_offset, v_buffer_raw);
          v_buffer_raw := utl_encode.base64_encode(v_buffer_raw);
          v_buffer_varchar := utl_raw.cast_to_varchar2(v_buffer_raw);
          dbms_lob.writeappend(v_clob, length(v_buffer_varchar), v_buffer_varchar);
          v_offset := v_offset + v_chunk_size;
        END LOOP;
        v_result := v_clob;
        dbms_lob.freetemporary(v_clob);
        RETURN v_result;
    END encode_base64;